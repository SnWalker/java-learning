# 数据类型

## 基本数据类型

| 数据类型 | 关键字  | 内存占用 |                 取值范围                  |
| :------: | :-----: | :------: | :---------------------------------------: |
|   整数   |  byte   |    1     |    负的2的7次方 ~ 2的7次方-1(-128~127)    |
|          |  short  |    2     | 负的2的15次方 ~ 2的15次方-1(-32768~32767) |
|          |   int   |    4     |        负的2的31次方 ~ 2的31次方-1        |
|          |  long   |    8     |        负的2的63次方 ~ 2的63次方-1        |
|  浮点数  |  float  |    4     |        1.401298e-45 ~ 3.402823e+38        |
|          | double  |    8     |      4.9000000e-324 ~ 1.797693e+308       |
|   字符   |  char   |    2     |                  0-65535                  |
|   布尔   | boolean |    1     |                true，false                |

byte类型取值范围：-128~127

int类型取值范围：-21亿多～21亿多

大小关系：double>float>long>int>short>byte

Java整数溢出：

<img src="assets/image-20251202222458942.png" width="50%" />

字面量128为int类型，变量a为byte类型，报编译错误。(byte)128表示强制类型转换，将int类型的128转换为byte类型，128的二进制数为1000 0000（前置0省略，共32位），二进制截断得到最低八位1000 0000，计算机底层采用二进制补码存储数字，八位二进制补码中1000 0000表示-128。关于补码，详见[链接](https://www.cnblogs.com/lf109/p/19299619)。

## 引用数据类型



## 如何在IDEA中阅读Java类库源码？

Command + 点击类名，IDEA自动解析.../lib/src.zip路径下对应类的源码。

```
src.zip
 └── java.base  <-- (JDK 9+ 引入的模块层级)
      └── java  <-- 文件夹
           └── util  <-- 文件夹
                ├── Scanner.java  <-- 这就是那个文件！
                ├── ArrayList.java
                ├── Date.java
                └── ...
```

<img src="assets/image-20251203134223269.png" alt="image-20251203134223269" width="50%" />



## 命名规范

变量名小驼峰，类名大驼峰（DO、PO、VO等除外），字面量大写且用'_'分隔单词。

开头、结尾不要用'$'和'_'。

<img src="assets/image-20251203142231071.png" alt="image-20251203142231071" style="zoom:50%;" />



# 运算符和表达式

## 除法运算符“/”：

整数除法：两个整型数相除会**舍弃**结果的**小数部分**，除非操作数中有小数。

浮点数除法：结果是近似值，可能**不精确**，例如 `10.0 / 3 = 3.3333333333333335`，因为计算机用有限位存储小数，无法精确表示某些十进制小数，又如`0.1 + 0.2 != 0.3`。

因此在金融计算等需要**高精度计算**的场景，使用能够进行精确小数计算的**BigDecimal类**。

<img src="assets/image-20251203151111632.png" alt="image-20251203151111632" style="zoom:35%;" />

## 类型转换

* 隐式类型转换：byte、short、char类型在表达式中参与运算时，先隐式转换为int类型，再进行计算。

  当把大范围类型赋值给小范围类型变量时，可能出现损失（即截断导致数值变化），报编译错误。

* 强制类型转换：目标数据类型 变量名 = （目标数据类型）被强转的数据；

  `(byte)128` 强制将int类型字面量128转换为byte类型，得到-128。

<img src="assets/image-20251203150102862.png" alt="image-20251203150102862" style="zoom:40%;" />

## “+”运算符

多个“+”构成的表达式，**从左至右**计算，有**String**参与进行**拼接**，有char参与就将**char转换为int**类型（根据ASCII码）。

（1）操作数有String类型

```java
1 + 2 + "abc" + 2 + 1
```

结果：“3abc21”

（2）操作数有char类型

```java
1 + ‘A’ + "abc" + 2 + 1
```

结果：“66abc21”

- **数字 `0`到 `9`**：对应的 ASCII 码范围是 **48 到 57**。
- **大写字母 `A`到 `Z`**：对应的 ASCII 码范围是 **65 到 90**。
- **小写字母 `a`到 `z`**：对应的 ASCII 码范围是 **97 到 122**。

## 逻辑运算符

（1）&& 与 &

* &&的两个操作数只能是**布尔类型**，且均为true时结果才为true，存在**逻辑短路**：当&&左侧表达式值为false时，不再执行右侧的表达式。
* &两侧操作数为布尔类型时，两个操作数均为true时结果为true，**无逻辑短路**；&两侧操作数为int类型时，执行**按位与**运算。

（2）||与|

类比&& 与 &。

<img src="assets/image-20251203160340453.png" alt="image-20251203160340453" style="zoom:40%;" />

## 三元运算符

三元表达式或者问号冒号表达式，存在短路。

格式：

​	关系表达式 ？ 表达式1 ：表达式2 ；

计算规则：

* 计算关系表达式的值。
* 如果关系表达式的值为真，那么执行表达式1。
* 如果关系表达式的值为假，那么执行表达式2。

# 流程控制语句

（1）**switch**

```java
switch (表达式) {
	case 1:
		语句体1;
		break;
	case 2:
		语句体2;
		break;
	...
	default:
		语句体n+1;
		break;
}
```

- 首先计算出表达式的值 。
- 其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结束。 
- 最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。 

- default可以放在任意位置，也可以省略。

- case穿透

  不写break会引发case穿透现象。

- switch在JDK12的新特性

```java
int number = 10;
switch (number) {
    case 1 -> System.out.println("一");
    case 2 -> System.out.println("二");
    case 3 -> System.out.println("三");
    default -> System.out.println("其他");
}
```

- switch和if第三种格式各自的使用场景

当我们需要对一个范围进行判断的时候，用多分枝if语句。

当我们把有限个数据列举出来，选择其中一个执行的时候，用switch语句。

（2）for与while如何选择？

明确循环次数用for，循环次数不确定但明确循环终止条件用while。



# 数组

**数组的定义**

```java
int[] array1;
int array2[];
```

**数组的初始化**

```java
// 静态初始化
int[] array1 = new int[]{1, 3, 5};
int[] array2 = {1, 2, 5};
// 动态初始化
int[] array3 = new int[3]; // 只指定大小，整数数组默认初始化为0
```

数组是引用数据类型，**数组变量**存储整个数组在内存中的第一个**地址值**。

<img src="assets/image-20251204104651462.png" alt="image-20251204104651462" style="zoom:30%;" />

**数组的默认初始化值**

```
整数类型：0          小数类型：0.0

布尔类型：false      字符类型：'\u0000'     引用类型：null
```

# 字符串

String效果上相当于字符数组char[]，底层原理是byte[]数组。

**常用构造方法**

| 方法名                      | 说明                                      |
| --------------------------- | ----------------------------------------- |
| public   String()           | 创建一个空白字符串对象，不含有任何内容    |
| public   String(char[] chs) | 根据字符数组的内容，来创建字符串对象      |
| public   String(byte[] bys) | 根据字节数组的内容，来创建字符串对象      |
| String s =   “abc”;         | 直接赋值的方式创建字符串对象，内容就是abc |

**两种创建字符串对象的区别**

* 构造方法
  使用new关键字会开辟一块新的内存空间，即便字符串内容相同，地址不同。
* 直接赋值
  JVM维护一个**字符串池**，若已有该字符串，则直接引用池中的这个字符串，地址相同。

**字符串的比较**

* == 运算符
  当操作数为基本数据类型时，比较值；操作数为引用数据类型时，比较的是对象地址值。
* str1.**equals(**str2**)**
  比较两个字符串的内容是否相同。

<img src="assets/image-20251205233104668.png" alt="image-20251205233104668" style="zoom:30%;" />

# 集合

* 什么是集合？
  集合是存储空间可变的存储容器，存储的元素数量可以改变。
* ArrayList集合的特点
  **长度可变**，只能存储**引用数据类型**。
* 泛型的使用
  用于**约束**集合中存储的元素的**数据类型**。

**ArrayList类常用方法**

构造方法

| 方法名             | 说明                 |
| ------------------ | -------------------- |
| public ArrayList() | 创建一个空的集合对象 |

成员方法

| 方法名                              | 说明                                   | 时空复杂度                                    |
| :---------------------------------- | :------------------------------------- | :-------------------------------------------- |
| public boolean add(要添加的元素)    | 将指定的元素追加到此集合的末尾         | **时间：** `O(1)` (摊销)<br>**空间：** `O(1)` |
| public boolean remove(要删除的元素) | 删除指定元素,返回值表示是否删除成功    | **时间：** `O(n)`<br>**空间：** `O(1)`        |
| public E remove(int index)          | 删除指定索引处的元素，返回被删除的元素 | **时间：** `O(n)`<br>**空间：** `O(1)`        |
| public E set(int index,E element)   | 修改指定索引处的元素，返回被修改的元素 | **时间：** `O(1)`<br>**空间：** `O(1)`        |
| public E get(int index)             | 返回指定索引处的元素                   | **时间：** `O(1)`<br>**空间：** `O(1)`        |
| public int size()                   | 返回集合中的元素的个数                 | **时间：** `O(1)`<br>**空间：** `O(1)`        |

1. **add()** 的时间复杂度：通常情况下是 **O(1)**。但当数组**容量不足**需要**扩容（Resize）**时，涉及到**数组复制**，此时为 **O(n)**。
2. **remove()** 的时间复杂度：remove(Object) 需要**先遍历查找元素**（耗时 `O(n)`），然后将后面的元素向前移动（耗时 `O(n)`），总计 `O(n)`。
3. **remove(int index)** **不需要查找**，但需要将该索引之后的所有元素向前移动一位，最坏情况是删除第一个元素，需要移动 `N−1` 个元素，所以是 `O(n)`。



**ArrayList懒加载与扩容机制**

JDK 21 中，ArrayList 默认构造通过**空数组**实现懒加载，首添时初始化为 **10**，后续满员按 **1.5 倍**（位运算）增长，伴随**数组拷贝**代价。

1. 懒加载机制 (Lazy Loading)

*   **初始化状态**：当调用无参构造器 `new ArrayList()` 时，内部数组并不会立即分配内存，而是赋值为一个**静态空数组** (`DEFAULTCAPACITY_EMPTY_ELEMENTDATA`)。此时容量（Capacity）为 0。
*   **首次分配**：只有当**第一次**调用 `add()` 方法添加元素时，才会触发扩容，将内部数组的容量初始化为**默认容量 10**。
    *   *注意：若使用 `new ArrayList(int capacity)` 指定容量，则会立即分配内存，无懒加载。*

2. 扩容机制 (Resizing)

*   **触发时机**：当当前元素个数（size）即将超过数组容量时触发。
*   **扩容算法**：新容量通常为旧容量的 **1.5 倍**。
    *   核心代码逻辑：`int newCapacity = oldCapacity + (oldCapacity >> 1);`
    *   使用位运算 `>> 1`（即除以 2）来提高效率。
    *   *示例：10 -> 15 -> 22 -> 33...*
*   **数据迁移**：计算出新容量后，底层创建一个新的数组，并使用 `Arrays.copyOf()` (底层调用 `System.arraycopy`) 将旧数组的数据复制到新数组中。这是一项耗时操作。

3. 边界与限制

*   **最大容量**：理论最大容量为 `Integer.MAX_VALUE`。但在通常情况下，软限制为 `Integer.MAX_VALUE - 8` (即 `MAX_ARRAY_SIZE`)，这是为了预留头部信息防止 OOM。
*   **缩容**：ArrayList **不会自动缩容**。若需要释放多余空间，需手动调用 `trimToSize()`。
